[Leetcode148. 排序链表](https://leetcode-cn.com/problems/sort-list/)  

法一:归并排序.  
```
class Solution:
    def find_mid(self, head):
        slow_p = fast_p = head 
        
        while True :
            if not fast_p:
                break
            if fast_p and not fast_p.next:
                break    
            pre_p = slow_p 
            slow_p = slow_p.next 
            fast_p = fast_p.next.next

        pre_p.next = None 
        return slow_p  
    
    def merge(self, head_1, head_2):
        cur = re_head = ListNode(-1)

        while head_1 and head_2:
            if head_1.val <= head_2.val:
                cur.next = head_1  
                head_1 = head_1.next 
            else:
                cur.next = head_2
                head_2 = head_2.next
            cur = cur.next 
        
        if head_1:
            cur.next = head_1 
        if head_2:
            cur.next = head_2

        return re_head.next  

    def sortList(self, head) :
        if not head:
            return head 
        if not head.next :
            return head 
        
        def merge_sort(head) :
            if not head.next:
                return head 

            mid = self.find_mid(head)
            
            head_1 = merge_sort(head)
            head_2 = merge_sort(mid) 

            re_head = self.merge(head_1, head_2) 
            return re_head
        

        re_head = merge_sort(head)
        return re_head 
```

法二:快速排序  
为何有效?  返回的mid位置固定, 前面的指针不会变.因为mid前面的比mid小. mid指向的, 不会影响mid.next, 所以有效.  
```

```
