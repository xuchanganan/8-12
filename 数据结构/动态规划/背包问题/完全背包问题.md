**完全背包问题**
[518. 零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2/)  
```dp[i][j] = dp[i-1][j] + dp[i][j - coins[i]]```

```
class Solution:
    def change(self, amount, coins) :
        # 硬币组合数, 要求不重复. 
        # 所以变成了 dp[i][j] = dp[i-1][j] + dp[i-1][j-v] + dp[i-1][j-2v] + dp[i-1][j-3v] + ...
        coin_len = len(coins)
        dp = [[0 for _ in range(amount+1)] for _ in range(coin_len+1)]
        for i in range(coin_len + 1):
            dp[i][0] = 1 
 
        for i in range(1, coin_len+1):
            for j in range(1, amount+1):
                dp[i][j] = dp[i-1][j]
                if j >= coins[i-1]:
                    dp[i][j] += dp[i][j-coins[i-1]]

        return dp[coin_len][amount]
```

**每个物品都可以使用若干次**  
[组合总和](https://leetcode-cn.com/problems/combination-sum/)  
难点在于去重, 因此动态规划的时候, 逐次迭代的是背包中的物品(最外层)  

```
class Solution:
    def combinationSum(self, candidates, target: int) -> List[List[int]]:
        N = len(candidates)
        M = target+1
        
        Ans = M * [0]
        for i in range(M):
            Ans[i] = list()
        
        Ans[0].append([])
        for i in range(N):
            for j in range(target-candidates[i]+1):
                for v in Ans[j]:
                    w = list(v)
                    w.append(candidates[i])
                    Ans[j+candidates[i]].append(w)
        
        return Ans[target]
```
